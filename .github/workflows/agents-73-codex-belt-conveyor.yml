# Closes the loop: merge successful Codex belt PRs, tidy branches and issues,
# and immediately nudge the dispatcher for the next item in the queue.
name: Agents 73 Codex Belt Conveyor

on:
  workflow_call:
    inputs:
      issue:
        description: 'Source issue number for the Codex belt PR'
        required: true
        type: number
      branch:
        description: 'Branch associated with the Codex belt PR (codex/issue-<n>)'
        required: true
        type: string
      pr_number:
        description: 'Pull request number to promote'
        required: true
        type: number
      head_sha:
        description: 'Head SHA used to evaluate status checks'
        required: false
        default: ''
        type: string
      dry_run:
        description: 'Preview conveyor actions without writes'
        required: false
        default: false
        type: boolean
    secrets:
      ACTIONS_BOT_PAT:
        required: false
      WORKFLOWS_APP_ID:
        required: false
      WORKFLOWS_APP_PRIVATE_KEY:
        required: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

concurrency:
  group: codex-belt-conveyor-${{ inputs.branch || format('issue-{0}', inputs.issue) || github.run_id }}
  cancel-in-progress: true

jobs:
  promote:
    name: Promote merged Codex belt PR
    runs-on: ubuntu-latest
    outputs:
      merged: ${{ steps.merge.outputs.merged || 'false' }}
      dry_run: ${{ steps.mode.outputs.dry_run || 'false' }}
      mode: ${{ steps.mode.outputs.mode_label || 'live' }}
      concurrency_group: ${{ steps.summary.outputs.concurrency_group || '' }}
    env:
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT || '' }}
      WORKFLOWS_APP_ID: ${{ secrets.WORKFLOWS_APP_ID || '' }}
      WORKFLOWS_APP_PRIVATE_KEY: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY || '' }}

    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        if: ${{ env.WORKFLOWS_APP_ID != '' && env.WORKFLOWS_APP_PRIVATE_KEY != '' }}
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ env.WORKFLOWS_APP_ID }}
          private-key: ${{ env.WORKFLOWS_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Select authentication token (app > PAT > GITHUB_TOKEN)
        id: select_token
        env:
          APP_TOKEN: ${{ steps.app_token.outputs.token || '' }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          token_value=""
          token_source=""

          if [ -n "${APP_TOKEN:-}" ]; then
            token_value="${APP_TOKEN}"
            token_source="WORKFLOWS_APP"
          elif [ -n "${ACTIONS_BOT_PAT:-}" ]; then
            token_value="${ACTIONS_BOT_PAT}"
            token_source="ACTIONS_BOT_PAT"
          elif [ -n "${GITHUB_TOKEN:-}" ]; then
            token_value="${GITHUB_TOKEN}"
            token_source="GITHUB_TOKEN"
          fi

          if [ -z "${token_value}" ]; then
            echo '::error::No authentication token available (App token, ACTIONS_BOT_PAT, or GITHUB_TOKEN).' >&2
            exit 1
          fi

          {
            echo "GH_CONVEYOR_TOKEN=${token_value}"
            echo "GH_TOKEN=${token_value}"
            echo "TOKEN_SOURCE=${token_source}"
          } >>"$GITHUB_ENV"
          printf 'token=%s\n' "${token_source}" >>"$GITHUB_OUTPUT"

      - name: Record token source
        env:
          TOKEN_SOURCE: ${{ steps.select_token.outputs.token || 'unknown' }}
          TOKEN_LOGIN: ${{ steps.app_token.outputs.app-slug || 'app-token' }}
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          Authentication
          ---------------
          EOF
          case "${TOKEN_SOURCE:-unknown}" in
            'WORKFLOWS_APP')
              cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          Using GitHub App token (WORKFLOWS_APP); write operations will use the app installation token instead of a PAT.
          EOF
              ;;
            'ACTIONS_BOT_PAT')
              cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          Using ACTIONS_BOT_PAT fallback. Configure WORKFLOWS_APP_ID and WORKFLOWS_APP_PRIVATE_KEY to enable the GitHub App path.
          EOF
              ;;
            'GITHUB_TOKEN')
              cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          Falling back to the default GITHUB_TOKEN. Writes may not trigger downstream workflows.
          EOF
              ;;
            *)
              echo "Unknown token source ${TOKEN_SOURCE:-unknown}" >>"$GITHUB_STEP_SUMMARY"
              ;;
          esac

      - name: Determine conveyor mode
        id: mode
        env:
          INPUT_DRY_RUN: ${{ inputs.dry_run }}
        run: |
          dry_run="${INPUT_DRY_RUN}"
          if [ "${dry_run}" = "true" ]; then
            mode_label="preview"
            echo "::notice::Conveyor executing in preview mode (dry run)."
          else
            mode_label="live"
            echo "::notice::Conveyor executing in live mode."
          fi

          {
            echo "dry_run=${dry_run}"
            echo "mode_label=${mode_label}"
          } >>"$GITHUB_OUTPUT"

      - name: Summarise invocation
        id: summary
        uses: actions/github-script@v8
        with:
          script: |
            const summary = core.summary;
            const dryRun = '${{ steps.mode.outputs.dry_run }}' === 'true';
            const modeLabel = '${{ steps.mode.outputs.mode_label }}' || (dryRun ? 'preview' : 'live');
            const issueRaw = '${{ inputs.issue }}';
            const issueValue = Number(issueRaw);
            const issueNumber = Number.isFinite(issueValue) && issueValue > 0 ? issueValue : null;
            const branch = '${{ inputs.branch }}'.trim();
            const prNumber = Number('${{ inputs.pr_number }}');
            const targetPr = Number.isFinite(prNumber) ? `#${prNumber}` : 'Unknown';
            const modeDisplay = dryRun ? 'Preview (dry run)' : 'Live (merge ready)';
            const runId = context.runId;
            const concurrencyKey = branch || issueNumber || runId;
            const concurrencyGroup = concurrencyKey ? `codex-belt-conveyor-${concurrencyKey}` : '';
            if (!concurrencyGroup) {
              core.setFailed('Unable to determine conveyor concurrency group.');
              return;
            }
            const issueDisplay = issueNumber ? `#${issueNumber}` : 'Unknown';
            const branchDisplay = branch || '(unspecified)';
            summary
              .addHeading('Codex Belt Conveyor')
              .addTable([
                [
                  { data: 'Issue', header: true },
                  { data: 'Branch', header: true },
                  { data: 'PR', header: true },
                  { data: 'Mode', header: true }
                ],
                [
                  issueDisplay,
                  branchDisplay,
                  targetPr,
                  modeDisplay
                ]
              ])
              .addTable([
                [
                  { data: 'Concurrency Group', header: true },
                  { data: 'Issue', header: true },
                  { data: 'Branch', header: true }
                ],
                [
                  concurrencyGroup,
                  issueDisplay,
                  branchDisplay
                ]
              ])
              .addBreak()
              .addRaw(`Resolved mode: **${modeLabel}**.`)
              .addBreak()
              .addRaw(`Target PR(s): **${targetPr}**.`)
              .write();
            core.setOutput('concurrency_group', concurrencyGroup);

      - name: Load PR details
        id: pr
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const prNumber = Number('${{ inputs.pr_number }}');
            const branch = '${{ inputs.branch }}'.trim();
            const expectedIssue = Number('${{ inputs.issue }}');
            const { owner, repo } = context.repo;

            const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (data.state !== 'open') {
              core.setFailed(`PR #${prNumber} is not open (state=${data.state}).`);
              return;
            }
            if (data.draft) {
              core.setFailed(`PR #${prNumber} is still marked as draft.`);
              return;
            }
            const headBranch = data.head && data.head.ref ? data.head.ref : '';
            if (headBranch !== branch) {
              core.setFailed(`PR #${prNumber} is running on ${headBranch} instead of ${branch}.`);
              return;
            }
            const match = headBranch.match(/^codex\/issue-(\d+)$/);
            if (!match) {
              core.setFailed(`Branch ${headBranch} is not a codex belt branch.`);
              return;
            }
            const inferredIssue = Number(match[1]);
            if (expectedIssue && inferredIssue !== expectedIssue) {
              core.warning(`Expected issue #${expectedIssue} but branch implies #${inferredIssue}. Using branch hint.`);
            }

            core.setOutput('issue', String(inferredIssue || expectedIssue || ''));
            core.setOutput('head_sha', data.head && data.head.sha ? data.head.sha : '');
            core.setOutput('base', data.base && data.base.ref ? data.base.ref : '');

      - name: Ensure Gate succeeded
        id: gate
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const headSha = '${{ inputs.head_sha }}'.trim() || '${{ steps.pr.outputs.head_sha }}';
            if (!headSha) {
              core.setFailed('Unable to determine head SHA for status inspection.');
              return;
            }
            const { owner, repo } = context.repo;
            const { data } = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: headSha });
            if (!data || data.state !== 'success') {
              const state = data && data.state ? data.state : '(unknown)';
              core.setFailed(`Combined status for ${headSha} is ${state}; conveyor requires success.`);
              return;
            }

      - name: Detect bootstrap-only placeholder change
        id: bootstrap
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const prNumber = Number('${{ inputs.pr_number }}');
            const inferredIssue = Number('${{ steps.pr.outputs.issue || inputs.issue }}') || null;
            const { owner, repo } = context.repo;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const placeholderPattern = inferredIssue
              ? new RegExp(`^agents/codex-${inferredIssue}\\.md$`)
              : /^agents\/codex-\d+\.md$/;

            let bootstrapOnly = files.length > 0;
            for (const file of files) {
              if (!placeholderPattern.test(file.filename)) {
                bootstrapOnly = false;
                break;
              }
              const additions = Number(file.additions || 0);
              const deletions = Number(file.deletions || 0);
              const changes = Number(file.changes || 0);
              const status = String(file.status || '').toLowerCase();
              // Allow exactly one addition/change for a bootstrap placeholder file.
              // The check uses `> 1` (not `>= 1`) to permit a single-line addition/change only.
              if (additions > 1 || deletions > 0 || changes > 1 || status !== 'added') {
                bootstrapOnly = false;
                break;
              }
              const patch = String(file.patch || '');
              const addedLines = patch
                .split('\n')
                .filter((line) => line.startsWith('+'))
                .map((line) => line.slice(1));
              // Do not filter out empty lines; count all added lines, including blank ones
              if (addedLines.length !== 1) {
                bootstrapOnly = false;
                break;
              }
              const expectedLine = inferredIssue
                ? `<!-- bootstrap for codex on issue #${inferredIssue} -->`
                : null;
              if (expectedLine && addedLines[0] !== expectedLine) {
                bootstrapOnly = false;
                break;
              }
            }

            const summary = core.summary;
            if (bootstrapOnly) {
              summary.addRaw('Detected bootstrap-only Codex PR; merge deferred until real changes are present.').addEOL();
            }
            await summary.write();

            core.setOutput('bootstrap', bootstrapOnly ? 'true' : 'false');

      - name: Merge PR with squash
        if: ${{ steps.mode.outputs.dry_run != 'true' && steps.bootstrap.outputs.bootstrap != 'true' }}
        id: merge
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const prNumber = Number('${{ inputs.pr_number }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: prNumber, merge_method: 'squash' });
              core.setOutput('merged', 'true');
            } catch (error) {
              core.setFailed(`Failed to merge PR #${prNumber}: ${error.message}`);
            }

      - name: Delete branch after merge
        if: ${{ steps.mode.outputs.dry_run != 'true' && steps.bootstrap.outputs.bootstrap != 'true' && steps.merge.outputs.merged == 'true' }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const branch = '${{ inputs.branch }}';
            const { owner, repo } = context.repo;
            try {
              await github.rest.git.deleteRef({ owner, repo, ref: `heads/${branch}` });
            } catch (error) {
              core.warning(`Failed to delete branch ${branch}: ${error.message}`);
            }

      - name: Close source issue
        if: ${{ steps.mode.outputs.dry_run != 'true' && steps.bootstrap.outputs.bootstrap != 'true' && steps.merge.outputs.merged == 'true' }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const issue = Number('${{ inputs.issue }}') || Number('${{ steps.pr.outputs.issue }}');
            const { owner, repo } = context.repo;
            if (!issue) {
              core.warning('Unable to resolve issue number; skipping issue closure.');
              return;
            }
            try {
              await github.rest.issues.update({ owner, repo, issue_number: issue, state: 'closed' });
            } catch (error) {
              core.warning(`Failed to close issue #${issue}: ${error.message}`);
            }
            try {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: issue, name: 'status:in-progress' });
            } catch (error) {
              if (error.status !== 404) {
                core.warning(`Failed to remove status:in-progress: ${error.message}`);
              }
            }
            try {
              await github.rest.issues.createComment({ owner, repo, issue_number: issue, body: 'Merged via Codex Belt Conveyor after Gate success.' });
            } catch (error) {
              core.warning(`Failed to comment on issue #${issue}: ${error.message}`);
            }

      - name: Leave merge confirmation on PR
        if: ${{ steps.mode.outputs.dry_run != 'true' && steps.bootstrap.outputs.bootstrap != 'true' && steps.merge.outputs.merged == 'true' }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const prNumber = Number('${{ inputs.pr_number }}');
            const issue = Number('${{ inputs.issue }}') || Number('${{ steps.pr.outputs.issue }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `Gate succeeded; merged automatically and closed issue #${issue || '(unknown)'}.` });
            } catch (error) {
              core.warning(`Failed to comment on PR #${prNumber}: ${error.message}`);
            }

      - name: Summarise conveyor preview
        if: ${{ steps.mode.outputs.dry_run == 'true' }}
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          Conveyor executed in preview mode. No merges or clean-up actions were performed.
          EOF

      - name: Re-dispatch dispatcher
        if: ${{ steps.mode.outputs.dry_run != 'true' && steps.bootstrap.outputs.bootstrap != 'true' && steps.merge.outputs.merged == 'true' }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ env.GH_CONVEYOR_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: 'agents-71-codex-belt-dispatcher.yml',
                ref: 'refs/heads/' + (process.env.GITHUB_REF_NAME || context.ref.replace('refs/heads/', ''))
              });
            } catch (error) {
              core.warning(`Failed to re-dispatch dispatcher: ${error.message}`);
            }
