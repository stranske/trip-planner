# Thin caller for autofix - delegates to Workflows repo reusable workflow
# Auto-fixes lint and format issues on PRs
#
# Triggers:
# - PR opened/synchronized/reopened
# - PR labeled with 'autofix' or 'autofix:clean'
#
# Copy this file to: .github/workflows/autofix.yml
#
# Required secrets:
# - SERVICE_BOT_PAT: PAT for pushing autofix commits (optional, uses GITHUB_TOKEN if not set)
name: Autofix

on:
  pull_request:
    types:
      - synchronize
      - opened
      - reopened
  pull_request_target:
    types:
      - labeled

permissions:
  actions: read
  checks: read
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: autofix-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  # Resolve PR context
  resolve:
    name: Resolve Context
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.context.outputs.should_run }}
      pr_number: ${{ steps.context.outputs.pr_number }}
      pr_head_ref: ${{ steps.context.outputs.head_ref }}
      pr_title: ${{ steps.context.outputs.pr_title }}
      pr_is_draft: ${{ steps.context.outputs.pr_is_draft }}
      pr_labels_json: ${{ steps.context.outputs.pr_labels_json }}
      same_repo: ${{ steps.context.outputs.same_repo }}
      caller_actor: ${{ steps.context.outputs.caller_actor }}
    steps:
      - name: Resolve PR context
        id: context
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setOutput('should_run', 'false');
              return;
            }

            // Event validation
              const isLabeled =
                context.eventName === 'pull_request_target' &&
                context.payload.action === 'labeled';
              const isPush =
                context.eventName === 'pull_request' &&
                ['synchronize', 'opened', 'reopened'].includes(context.payload.action);

            if (!isLabeled && !isPush) {
              core.info(`Unsupported event: ${context.eventName}/${context.payload.action}`);
              core.setOutput('should_run', 'false');
              return;
            }

            // Label validation for labeled events
            if (isLabeled) {
              const label = context.payload.label?.name?.toLowerCase();
              if (label !== 'autofix' && label !== 'autofix:clean') {
                core.info(`Label '${label}' is not an autofix trigger.`);
                core.setOutput('should_run', 'false');
                return;
              }
            }

            // Explicitly check for null repo (deleted fork case)
              const sameRepo =
                pr.head.repo !== null &&
                pr.head.repo.full_name === pr.base.repo?.full_name;
            const labels = (pr.labels || []).map(l => l.name);

            core.setOutput('should_run', 'true');
            core.setOutput('pr_number', pr.number);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('pr_title', pr.title);
            core.setOutput('pr_is_draft', pr.draft ? 'true' : 'false');
            core.setOutput('pr_labels_json', JSON.stringify(labels));
            core.setOutput('same_repo', sameRepo ? 'true' : 'false');
            core.setOutput('caller_actor', context.actor);

  # Call reusable autofix workflow
  autofix:
    needs: resolve
    if: needs.resolve.outputs.should_run == 'true'
    uses: stranske/Workflows/.github/workflows/reusable-18-autofix.yml@v1
    with:
      pr_number: ${{ fromJson(needs.resolve.outputs.pr_number) }}
      pr_head_ref: ${{ needs.resolve.outputs.pr_head_ref }}
      pr_title: ${{ needs.resolve.outputs.pr_title }}
      pr_is_draft: ${{ needs.resolve.outputs.pr_is_draft == 'true' }}
      pr_labels_json: ${{ needs.resolve.outputs.pr_labels_json }}
      same_repo: ${{ needs.resolve.outputs.same_repo == 'true' }}
      caller_actor: ${{ needs.resolve.outputs.caller_actor }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      WORKFLOWS_APP_ID: ${{ secrets.WORKFLOWS_APP_ID }}
      WORKFLOWS_APP_PRIVATE_KEY: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}
