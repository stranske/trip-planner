# Thin caller for issue intake - delegates to Workflows repo reusable workflow
# Assigns agents (Codex, Copilot) to issues when labeled with agent:* labels
#
# Triggers:
# - Issue opened/reopened/labeled with agent:codex, agent:copilot, etc.
# - Manual dispatch for testing
#
# This file: .github/workflows/agents-63-issue-intake.yml
#
# Required secrets:
# - SERVICE_BOT_PAT: PAT for service bot account (comments, labels)
# - OWNER_PR_PAT: PAT for creating PRs on behalf of repository owner
name: Agents Issue Intake

on:
  issues:
    types:
      - opened
      - reopened
      - labeled
      - unlabeled
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process (optional for manual trigger)"
        required: false
        type: string
      bridge_agent:
        description: "Agent to use (codex, copilot, etc.)"
        required: false
        type: string
        default: "codex"
      post_codex_comment:
        description: "Auto-post activation comment"
        required: false
        type: boolean
        default: true
      bridge_draft_pr:
        description: "Open bootstrap PRs as draft"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: issue-intake-${{ github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  # Gate: only proceed if issue has agent:* or agents:* label (or workflow_dispatch)
  check_labels:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      contains(toJson(github.event.issue.labels.*.name), 'agent:') ||
      contains(toJson(github.event.issue.labels.*.name), 'agents:')
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      agent: ${{ steps.check.outputs.agent }}
    steps:
      - name: Check labels and extract info
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const eventName = context.eventName;
            let issueNumber = '${{ inputs.issue_number }}' || '';
            let agent = '${{ inputs.bridge_agent }}' || 'codex';

            if (eventName === 'issues') {
              const issue = context.payload.issue;
              issueNumber = String(issue.number);

              // Extract agent from labels (agent:codex, agents:codex, etc.)
              const labels = issue.labels.map(l => l.name);
              const agentLabel = labels.find(l => /^agents?:[a-z]+$/i.test(l) && !l.includes('keepalive'));
              if (agentLabel) {
                agent = agentLabel.replace(/^agents?:/, '').toLowerCase();
              }

              // Check if any agent label exists
              const hasAgentLabel = labels.some(l => /^agents?:/.test(l));
              if (!hasAgentLabel) {
                core.setOutput('should_run', 'false');
                return;
              }
            }

            core.setOutput('should_run', 'true');
            core.setOutput('issue_number', issueNumber);
            core.setOutput('agent', agent);
            console.log(`Processing issue #${issueNumber} with agent: ${agent}`);

  # Call the Workflows repo reusable issue bridge
  bridge:
    needs: check_labels
    if: needs.check_labels.outputs.should_run == 'true'
    uses: stranske/Workflows/.github/workflows/reusable-agents-issue-bridge.yml@main
    with:
      agent: ${{ needs.check_labels.outputs.agent }}
      issue_number: ${{ needs.check_labels.outputs.issue_number }}
      mode: "invite"
      post_agent_comment: ${{ inputs.post_codex_comment == true && 'true' || 'false' }}
      agent_pr_draft: ${{ inputs.bridge_draft_pr == true && 'true' || 'false' }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      owner_pr_pat: ${{ secrets.OWNER_PR_PAT }}
