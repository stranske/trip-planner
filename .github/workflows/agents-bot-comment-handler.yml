# Bot Comment Handler - Thin caller for consumer repos
#
# Addresses unresolved review comments from bots (Copilot, CodeRabbit, etc.)
# by dispatching the configured agent to fix them.
#
# Triggers:
# - PR labeled with 'autofix:bot-comments' (manual trigger)
# - Gate workflow completion (automatic for agent PRs)
# - Manual dispatch for testing
#
# Agent selection:
# - Uses PR's agent:* label (agent:codex, agent:claude, etc.)
# - Falls back to Codex if no agent label
#
# Workflow file: .github/workflows/agents-bot-comment-handler.yml

name: Agents Bot Comment Handler

on:
  # Manual trigger via label
  pull_request:
    types: [labeled]

  # Automatic trigger after Gate completes (for agent PRs)
  # Note: branches-ignore is not supported for workflow_run, filtering is done in job logic
  workflow_run:
    workflows: ["Gate"]
    types: [completed]

  # Manual dispatch for testing
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to process'
        required: true
        type: string
      dry_run:
        description: 'Preview without making changes'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read

concurrency:
  group: >-
    bot-comments-${{ github.event.pull_request.number ||
      github.event.workflow_run.pull_requests[0].number ||
      inputs.pr_number ||
      github.run_id }}
  cancel-in-progress: false

jobs:
  # Resolve PR number from different trigger types
  resolve:
    name: Resolve PR
    if: vars.USE_CONSOLIDATED_WORKFLOWS != 'true'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.resolve.outputs.pr_number }}
      should_run: ${{ steps.resolve.outputs.should_run }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/actions/setup-api-client
            .github/scripts/github-api-with-retry.js
          sparse-checkout-cone-mode: false

      - name: Setup API client
        uses: ./.github/actions/setup-api-client
        with:
          secrets: ${{ toJSON(secrets) }}
          github_token: ${{ github.token }}

      - name: Resolve PR number and check conditions
        id: resolve
        uses: actions/github-script@v8
        with:
          script: |
            const { createTokenAwareRetry } = require('./.github/scripts/github-api-with-retry.js');
            const { withRetry } = await createTokenAwareRetry({ github, core });

            const eventName = context.eventName;
            let prNumber = null;
            let shouldRun = false;

            if (eventName === 'workflow_dispatch') {
              prNumber = '${{ inputs.pr_number }}';
              shouldRun = true;
              console.log(`Manual dispatch for PR #${prNumber}`);
            }
            else if (eventName === 'pull_request') {
              // Only run if labeled with autofix:bot-comments
              const label = context.payload.label?.name;
              if (label === 'autofix:bot-comments') {
                prNumber = context.payload.pull_request.number;
                shouldRun = true;
                console.log(`Label trigger for PR #${prNumber}`);
              } else {
                console.log(`Ignoring label: ${label}`);
              }
            }
            else if (eventName === 'workflow_run') {
              // Only run if Gate succeeded and PR has agent:* label
              const workflowRun = context.payload.workflow_run;

              let defaultBranch = context.payload.repository?.default_branch;
              if (!defaultBranch) {
                const repoResponse = await withRetry((client) => client.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                }));
                defaultBranch = repoResponse.data?.default_branch;
              }
              if (!defaultBranch) {
                console.log('Could not determine default branch; skipping.');
                core.setOutput('should_run', 'false');
                return;
              }

              // Skip default branch
              if (workflowRun.head_branch === defaultBranch) {
                console.log(`Skipping default branch ${defaultBranch}`);
                core.setOutput('should_run', 'false');
                return;
              }

              if (workflowRun.conclusion !== 'success') {
                console.log(`Gate did not succeed (${workflowRun.conclusion}), skipping`);
                core.setOutput('should_run', 'false');
                return;
              }

              // Get PR from workflow run
              const prs = workflowRun.pull_requests;
              if (!prs || prs.length === 0) {
                console.log('No PR associated with workflow run');
                core.setOutput('should_run', 'false');
                return;
              }

              prNumber = prs[0].number;

              // Check if PR has agent label
              let pr;
              try {
                const response = await withRetry((client) => client.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                }));
                pr = response.data;
              } catch (error) {
                console.log(
                  `Failed to fetch PR #${prNumber} details, skipping. ` +
                    `Error: ${error.message || error}`
                );
                core.setOutput('should_run', 'false');
                return;
              }

              const hasAgentLabel = pr.labels.some(l => /^agent:/.test(l.name));
              if (!hasAgentLabel) {
                console.log(`PR #${prNumber} has no agent label, skipping`);
                core.setOutput('should_run', 'false');
                return;
              }

              shouldRun = true;
              console.log(`Gate completion trigger for agent PR #${prNumber}`);
            }

            core.setOutput('pr_number', prNumber || '');
            core.setOutput('should_run', shouldRun ? 'true' : 'false');

  # Call the reusable workflow
  handle:
    name: Handle bot comments
    needs: resolve
    if: vars.USE_CONSOLIDATED_WORKFLOWS != 'true' && needs.resolve.outputs.should_run == 'true'
    uses: stranske/Workflows/.github/workflows/reusable-bot-comment-handler.yml@main
    with:
      pr_number: ${{ needs.resolve.outputs.pr_number }}
      dry_run: ${{ inputs.dry_run == true }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      gh_app_id: ${{ secrets.GH_APP_ID }}
      gh_app_private_key: ${{ secrets.GH_APP_PRIVATE_KEY }}

  # Remove the trigger label after processing
  cleanup:
    name: Cleanup
    needs: [resolve, handle]
    if: |
      always() &&
      vars.USE_CONSOLIDATED_WORKFLOWS != 'true' &&
      github.event_name == 'pull_request' &&
      github.event.label.name == 'autofix:bot-comments'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/actions/setup-api-client
            .github/scripts/github-api-with-retry.js
          sparse-checkout-cone-mode: false

      - name: Setup API client
        uses: ./.github/actions/setup-api-client
        with:
          secrets: ${{ toJSON(secrets) }}
          github_token: ${{ github.token }}

      - name: Remove trigger label
        uses: actions/github-script@v8
        with:
          script: |
            const { createTokenAwareRetry } = require('./.github/scripts/github-api-with-retry.js');
            const { withRetry } = await createTokenAwareRetry({ github, core });

            try {
              await withRetry((client) => client.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                name: 'autofix:bot-comments'
              }));
              console.log('Removed autofix:bot-comments label');
            } catch (error) {
              console.log(`Could not remove label: ${error.message}`);
            }
