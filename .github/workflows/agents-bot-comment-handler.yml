# Bot Comment Handler - Thin caller for consumer repos
#
# Addresses unresolved review comments from bots (Copilot, CodeRabbit, etc.)
# by dispatching the configured agent to fix them.
#
# Triggers:
# - PR labeled with 'autofix:bot-comments' (manual trigger)
# - Gate workflow completion (automatic for agent PRs)
# - Manual dispatch for testing
#
# Agent selection:
# - Uses PR's agent:* label (agent:codex, agent:claude, etc.)
# - Falls back to Codex if no agent label
#
# Workflow file: .github/workflows/agents-bot-comment-handler.yml

name: Agents Bot Comment Handler

on:
  # Manual trigger via label
  pull_request:
    types: [labeled]

  # Automatic trigger after Gate completes (for agent PRs)
  # Note: branches-ignore is not supported for workflow_run, filtering is done in job logic
  workflow_run:
    workflows: ["Gate"]
    types: [completed]

  # Manual dispatch for testing
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to process'
        required: true
        type: string
      dry_run:
        description: 'Preview without making changes'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read

concurrency:
  group: >-
    bot-comments-${{ github.event.pull_request.number ||
      github.event.workflow_run.pull_requests[0].number ||
      inputs.pr_number ||
      github.run_id }}
  cancel-in-progress: false

jobs:
  # Resolve PR number from different trigger types
  resolve:
    name: Resolve PR
    if: vars.USE_CONSOLIDATED_WORKFLOWS != 'true'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.resolve.outputs.pr_number }}
      should_run: ${{ steps.resolve.outputs.should_run }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/actions/setup-api-client
            .github/scripts/github-api-with-retry.js
            .github/scripts/token_load_balancer.js
          sparse-checkout-cone-mode: false

      - name: Setup API client
        uses: ./.github/actions/setup-api-client
        with:
          secrets: ${{ toJSON(secrets) }}
          github_token: ${{ github.token }}

      - name: Resolve PR number and check conditions
        id: resolve
        uses: actions/github-script@v8
        with:
          script: |
            const { createTokenAwareRetry } = require('./.github/scripts/github-api-with-retry.js');
            const { withRetry } = await createTokenAwareRetry({ github, core });

            const eventName = context.eventName;
            let prNumber = null;
            let shouldRun = false;

            if (eventName === 'workflow_dispatch') {
              prNumber = '${{ inputs.pr_number }}';
              shouldRun = true;
              console.log(`Manual dispatch for PR #${prNumber}`);
            }
            else if (eventName === 'pull_request') {
              // Only run if labeled with autofix:bot-comments
              const label = context.payload.label?.name;
              if (label === 'autofix:bot-comments') {
                prNumber = context.payload.pull_request.number;
                shouldRun = true;
                console.log(`Label trigger for PR #${prNumber}`);
              } else {
                console.log(`Ignoring label: ${label}`);
              }
            }
            else if (eventName === 'workflow_run') {
              // Only run if Gate succeeded and PR has agent:* label
              const workflowRun = context.payload.workflow_run;

              let defaultBranch = context.payload.repository?.default_branch;
              if (!defaultBranch) {
                const repoResponse = await withRetry((client) => client.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                }));
                defaultBranch = repoResponse.data?.default_branch;
              }
              if (!defaultBranch) {
                console.log('Could not determine default branch; skipping.');
                core.setOutput('should_run', 'false');
                return;
              }

              // Skip default branch
              if (workflowRun.head_branch === defaultBranch) {
                console.log(`Skipping default branch ${defaultBranch}`);
                core.setOutput('should_run', 'false');
                return;
              }

              if (workflowRun.conclusion !== 'success') {
                console.log(`Gate did not succeed (${workflowRun.conclusion}), skipping`);
                core.setOutput('should_run', 'false');
                return;
              }

              // Get PR from workflow run
              const prs = workflowRun.pull_requests;
              if (!prs || prs.length === 0) {
                console.log('No PR associated with workflow run');
                core.setOutput('should_run', 'false');
                return;
              }

              prNumber = prs[0].number;

              // Check if PR has agent label
              let pr;
              try {
                const response = await withRetry((client) => client.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                }));
                pr = response.data;
              } catch (error) {
                console.log(
                  `Failed to fetch PR #${prNumber} details, skipping. ` +
                    `Error: ${error.message || error}`
                );
                core.setOutput('should_run', 'false');
                return;
              }

              const hasAgentLabel = pr.labels.some(l => /^agent:/.test(l.name));
              if (!hasAgentLabel) {
                console.log(`PR #${prNumber} has no agent label, skipping`);
                core.setOutput('should_run', 'false');
                return;
              }

              // Skip auto-pilot PRs â€” auto-pilot manages its own quality flow
              const hasAutoPilot = pr.labels.some(l => l.name === 'agents:auto-pilot');
              if (hasAutoPilot) {
                console.log(`PR #${prNumber} is auto-pilot managed, skipping bot-comment handler`);
                core.setOutput('should_run', 'false');
                return;
              }

              shouldRun = true;
              console.log(`Gate completion trigger for agent PR #${prNumber}`);
            }

            core.setOutput('pr_number', prNumber || '');
            core.setOutput('should_run', shouldRun ? 'true' : 'false');

  # Dismiss ignored-path bot reviews to prevent noisy inline comments
  dismiss_ignored:
    name: Dismiss ignored bot reviews
    # Dismisses the review state (not individual comments) so bot reviews
    # on ignored paths don't block merge or clutter the PR timeline.
    needs: resolve
    if: vars.USE_CONSOLIDATED_WORKFLOWS != 'true' && needs.resolve.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/actions/setup-api-client
            .github/scripts/github-api-with-retry.js
            .github/scripts/token_load_balancer.js
          sparse-checkout-cone-mode: false

      - name: Setup API client
        uses: ./.github/actions/setup-api-client
        with:
          secrets: ${{ toJSON(secrets) }}
          github_token: ${{ github.token }}

      - name: Dismiss ignored-path bot reviews
        uses: actions/github-script@v8
        env:
          BOT_AUTHORS: >-
            Copilot,copilot[bot],github-actions[bot],
            coderabbitai[bot],chatgpt-codex-connector[bot]
          IGNORED_PATHS: '.agents/,scripts/langchain/prompts/,docs/'
        with:
          script: |
            const prNumber = parseInt('${{ needs.resolve.outputs.pr_number }}', 10);
            if (!prNumber) {
              console.log('No PR number resolved; skipping dismiss step.');
              return;
            }

            const { createTokenAwareRetry } = require('./.github/scripts/github-api-with-retry.js');
            const { withRetry } = await createTokenAwareRetry({ github, core });

            const botAuthors = (process.env.BOT_AUTHORS || '')
              .split(',')
              .map((value) => value.trim().toLowerCase())
              .filter(Boolean);
            const ignoredPaths = (process.env.IGNORED_PATHS || '')
              .split(',')
              .map((value) => value.trim())
              .filter(Boolean);

            if (botAuthors.length === 0 || ignoredPaths.length === 0) {
              console.log('Missing bot authors or ignored paths; skipping dismiss step.');
              return;
            }

            const [comments, reviews] = await Promise.all([
              withRetry((client) => client.paginate(client.rest.pulls.listReviewComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100,
              })),
              withRetry((client) => client.paginate(client.rest.pulls.listReviews, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100,
              })),
            ]);

            const reviewsById = new Map(reviews.map((review) => [review.id, review]));
            const commentsByReview = new Map();

            for (const comment of comments) {
              const reviewId = comment.pull_request_review_id;
              if (!reviewId) {
                continue;
              }

              const entry = commentsByReview.get(reviewId) || {
                total: 0,
                ignored: 0,
                paths: [],
                ignoredComments: [],
              };

              entry.total += 1;
              const commentPath = comment.path || '';
              entry.paths.push(commentPath);

              if (ignoredPaths.some((prefix) => commentPath.startsWith(prefix))) {
                entry.ignored += 1;
                entry.ignoredComments.push({
                  id: comment.id,
                  path: commentPath,
                  login: comment.user?.login || 'unknown',
                });
                const botName = comment.user?.login;
                console.log(
                  'Auto-dismiss candidate: ' +
                  `comment=${comment.id} ` +
                  `bot=${botName} path=${commentPath}`
                );
              }

              commentsByReview.set(reviewId, entry);
            }

            let dismissed = 0;
            for (const [reviewId, review] of reviewsById) {
              const login = (review.user?.login || '').toLowerCase();
              if (!botAuthors.includes(login)) {
                continue;
              }

              const entry = commentsByReview.get(reviewId);
              if (!entry || entry.total === 0) {
                continue;
              }

              if (entry.ignored !== entry.total) {
                continue;
              }

              const uniquePaths = Array.from(new Set(entry.paths)).filter(Boolean);
              for (const ignored of entry.ignoredComments) {
                console.log(
                  'Auto-dismissed review comment: ' +
                  `comment=${ignored.id} ` +
                  `bot=${ignored.login} ` +
                  `path=${ignored.path}`
                );
              }
              const message = [
                'Auto-dismissed bot review: all comments target ignored paths.',
                `Ignored paths: ${ignoredPaths.join(', ')}`,
                `Review paths: ${uniquePaths.join(', ') || '(none)'}`,
              ].join('\n');

              await withRetry((client) => client.rest.pulls.dismissReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                review_id: reviewId,
                message,
              }));

              dismissed += 1;
              const paths = uniquePaths.join(', ');
              console.log(
                `Dismissed review ${reviewId} ` +
                `from ${review.user?.login} ` +
                `for paths: ${paths}`
              );
            }

            console.log(`Dismissed ${dismissed} bot review(s) targeting ignored paths.`);

  # Call the reusable workflow
  handle:
    name: Handle bot comments
    needs: resolve
    if: vars.USE_CONSOLIDATED_WORKFLOWS != 'true' && needs.resolve.outputs.should_run == 'true'
    uses: stranske/Workflows/.github/workflows/reusable-bot-comment-handler.yml@main
    with:
      pr_number: ${{ needs.resolve.outputs.pr_number }}
      dry_run: ${{ inputs.dry_run == true }}
      ignored_paths: '.agents/,scripts/langchain/prompts/,docs/'
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      gh_app_id: ${{ secrets.GH_APP_ID }}
      gh_app_private_key: ${{ secrets.GH_APP_PRIVATE_KEY }}

  # Remove the trigger label after processing
  cleanup:
    name: Cleanup
    needs: [resolve, handle]
    if: |
      always() &&
      vars.USE_CONSOLIDATED_WORKFLOWS != 'true' &&
      github.event_name == 'pull_request' &&
      github.event.label.name == 'autofix:bot-comments'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/actions/setup-api-client
            .github/scripts/github-api-with-retry.js
            .github/scripts/token_load_balancer.js
          sparse-checkout-cone-mode: false

      - name: Setup API client
        uses: ./.github/actions/setup-api-client
        with:
          secrets: ${{ toJSON(secrets) }}
          github_token: ${{ github.token }}

      - name: Remove trigger label
        uses: actions/github-script@v8
        with:
          script: |
            const { createTokenAwareRetry } = require('./.github/scripts/github-api-with-retry.js');
            const { withRetry } = await createTokenAwareRetry({ github, core });

            try {
              await withRetry((client) => client.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                name: 'autofix:bot-comments'
              }));
              console.log('Removed autofix:bot-comments label');
            } catch (error) {
              console.log(`Could not remove label: ${error.message}`);
            }
