name: Create New PR from Verification

# Creates a follow-up issue from verification feedback, then
# triggers auto-pilot to prepare a new PR.
#
# Trigger: Add `verify:create-new-pr` label to a merged PR

on:
  pull_request_target:
    types: [labeled]

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: write
  models: read

env:
  PYTHON_VERSION: "3.12"

concurrency:
  group: >-
    agents-verify-to-new-pr-${{ github.repository }}-${{
      github.event.pull_request.number || github.run_id
    }}
  cancel-in-progress: false

jobs:
  create-new-pr:
    if: github.event.label.name == 'verify:create-new-pr'
    runs-on: ubuntu-latest
    steps:
      - name: Check PR is merged
        id: check-merged
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr.merged) {
              core.setFailed('PR must be merged before creating follow-up issue');
              return;
            }
            core.setOutput('merged', 'true');
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_title', pr.title);

      - name: Select GitHub token
        id: select-token
        if: steps.check-merged.outputs.merged == 'true'
        env:
          CODESPACES_WORKFLOWS: ${{ secrets.CODESPACES_WORKFLOWS }}
          OWNER_PR_PAT: ${{ secrets.OWNER_PR_PAT }}
          SERVICE_BOT_PAT: ${{ secrets.SERVICE_BOT_PAT }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          if [ -n "$CODESPACES_WORKFLOWS" ]; then
            echo "token=$CODESPACES_WORKFLOWS" >> "$GITHUB_OUTPUT"
            echo "source=codespaces" >> "$GITHUB_OUTPUT"
          elif [ -n "$OWNER_PR_PAT" ]; then
            echo "token=$OWNER_PR_PAT" >> "$GITHUB_OUTPUT"
            echo "source=owner-pat" >> "$GITHUB_OUTPUT"
          elif [ -n "$SERVICE_BOT_PAT" ]; then
            echo "token=$SERVICE_BOT_PAT" >> "$GITHUB_OUTPUT"
            echo "source=service-bot" >> "$GITHUB_OUTPUT"
          else
            echo "token=$GITHUB_TOKEN" >> "$GITHUB_OUTPUT"
            echo "source=github-token" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout repository
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/checkout@v6
        with:
          repository: stranske/Workflows
          token: ${{ steps.select-token.outputs.token }}
          sparse-checkout: |
            .github/actions/export-load-balancer-tokens
            .github/scripts/github-api-with-retry.js
            scripts/langchain
            tools

      - name: Export load balancer tokens
        uses: ./.github/actions/export-load-balancer-tokens
        with:
          github_token: ${{ github.token }}
          token_rotation_json: ${{ secrets.TOKEN_ROTATION_JSON }}
          token_rotation_env_keys: ${{ vars.TOKEN_ROTATION_ENV_KEYS }}
      - name: Set up Python
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        if: steps.check-merged.outputs.merged == 'true'
        run: |
          pip install langchain langchain-openai requests

      - name: Collect verification and original issue data
        id: collect
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry, paginateWithRetry } = retryHelpers;
            const prNumber = context.payload.pull_request.number;

            // Get all PR comments (handle pagination)
            const comments = await paginateWithRetry(
              github, github.rest.issues.listComments,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100
              }
            );

            // Find verification comment(s) - both evaluate and compare
            const verifyComments = comments.filter(c =>
              c.body.includes('## PR Verification Report') ||
              c.body.includes('## PR Verification Comparison') ||
              c.body.includes('### Concerns') ||
              c.body.includes('Verdict:') ||
              c.body.includes('### âš ï¸ Issues Detected')
            );

            if (verifyComments.length === 0) {
              core.setFailed(
                'No verification comment found. ' +
                'Add verify:evaluate or verify:compare label first.'
              );
              return;
            }

            // Combine all verification comments
            const verificationText = verifyComments.map(c => c.body).join('\n\n---\n\n');
            fs.writeFileSync('verification_data.txt', verificationText);
            core.info(`Found ${verifyComments.length} verification comment(s)`);

            // Extract linked issue from PR body
            const prBody = context.payload.pull_request.body || '';
            const issueMatches = prBody.match(
              /(close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*#(\d+)/gi
            );
            let linkedIssueNumber = null;

            if (issueMatches) {
              const match = issueMatches[0].match(/#(\d+)/);
              if (match) {
                linkedIssueNumber = parseInt(match[1]);
              }
            }

            // Also check PR title for issue reference
            if (!linkedIssueNumber) {
              const titleMatch = context.payload.pull_request.title.match(/#(\d+)/);
              if (titleMatch) {
                linkedIssueNumber = parseInt(titleMatch[1]);
              }
            }

            let originalIssueBody = '';
            let originalIssueTitle = '';

            if (linkedIssueNumber) {
              core.info(`Found linked issue #${linkedIssueNumber}`);
              try {
                const { data: issue } = await withRetry(() => github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: linkedIssueNumber
                }));
                originalIssueBody = issue.body || '';
                originalIssueTitle = issue.title || '';
                core.setOutput('original_issue_number', linkedIssueNumber);
                core.setOutput('original_issue_title', originalIssueTitle);
              } catch (error) {
                core.warning(`Could not fetch issue #${linkedIssueNumber}: ${error.message}`);
              }
            } else {
              core.warning('No linked issue found in PR body or title');
            }

            fs.writeFileSync('original_issue.txt', originalIssueBody);

            // Set outputs
            core.setOutput('has_original_issue', linkedIssueNumber ? 'true' : 'false');

      - name: Generate follow-up issue
        id: generate
        if: steps.check-merged.outputs.merged == 'true'
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ steps.select-token.outputs.token }}
          ORIGINAL_ISSUE_NUMBER: ${{ steps.collect.outputs.original_issue_number }}
          ORIGINAL_ISSUE_TITLE: ${{ steps.collect.outputs.original_issue_title }}
          PR_NUMBER: ${{ steps.check-merged.outputs.pr_number }}
        run: |
          # Generate using Python script
          python scripts/langchain/followup_issue_generator.py \
            --verification-comment verification_data.txt \
            --original-issue original_issue.txt \
            --original-issue-number "${ORIGINAL_ISSUE_NUMBER:-0}" \
            --original-issue-title "${ORIGINAL_ISSUE_TITLE:-}" \
            --pr-number "${PR_NUMBER}" \
            --json \
            --output followup_issue.json

          # Extract title and body for GitHub Actions
          echo "issue_title=$(jq -r '.title' followup_issue.json)" >> "$GITHUB_OUTPUT"

          # Use delimiter for multi-line body
          {
            echo 'issue_body<<EOF_ISSUE_BODY'
            jq -r '.body' followup_issue.json
            echo 'EOF_ISSUE_BODY'
          } >> "$GITHUB_OUTPUT"

      - name: Fallback to simple extraction
        id: fallback
        if: steps.generate.outcome == 'failure' && steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            // Fallback to original simple extraction if Python script fails
            const fs = require('fs');
            const prNumber = context.payload.pull_request.number;
            const prUrl = context.payload.pull_request.html_url;

            let verificationText = '';
            try {
              verificationText = fs.readFileSync('verification_data.txt', 'utf8');
            } catch (error) {
              core.warning('Could not read verification data');
            }

            // Extract concerns using regex
            const concernsRegex = /### Concerns\s*\n([\s\S]*?)(?=###|##|$)/i;
            const concernsMatch = verificationText.match(concernsRegex);
            let concerns = concernsMatch
              ? concernsMatch[1].trim()
              : 'No specific concerns extracted.';

            // Extract low scores
            const scoreMatches = [...verificationText.matchAll(/(\w+):\s*(\d+)\/10/gi)];
            const lowScores = scoreMatches
              .filter(m => parseInt(m[2]) < 7)
              .map(m => `- ${m[1]}: ${m[2]}/10`);

            // Extract verdict
            const verdictMatch = verificationText.match(/Verdict:\s*\*?\*?(\w+)\*?\*?/i);
            const verdict = verdictMatch ? verdictMatch[1] : 'Unknown';

            // Build issue body with proper indentation for YAML compatibility
            const taskItems = concerns.split('\n')
              .filter(l => l.trim())
              .map(c => `- [ ] ${c.replace(/^[-*]\s*/, '')}`)
              .join('\n');

            const lowScoreSection = lowScores.length > 0
              ? '\n## Implementation Notes\n\nLow scores to address:\n' +
                lowScores.join('\n')
              : '';

            const issueBody = [
              '## Why',
              '',
              `PR #${prNumber} was verified with verdict **${verdict}**. ` +
              'This follow-up issue tracks the remaining concerns.',
              '',
              '## Scope',
              '',
              `Address verification concerns from [PR #${prNumber}](${prUrl}).`,
              '',
              '## Tasks',
              '',
              taskItems,
              '',
              '## Acceptance Criteria',
              '',
              '- [ ] All verification concerns addressed or documented',
              '- [ ] Tests updated if needed',
              '- [ ] Re-verification passes',
              lowScoreSection,
              '',
              '---',
              '*Auto-generated by verify-to-new-pr workflow (fallback mode)*'
            ].join('\n');

            core.setOutput(
              'issue_title',
              `[Follow-up] Address verification concerns from PR #${prNumber}`
            );

            // Use environment file for multi-line output
            const envFile = process.env.GITHUB_OUTPUT;
            const delimiter = 'EOF_BODY';
            fs.appendFileSync(envFile, `issue_body<<${delimiter}\n${issueBody}\n${delimiter}\n`);

      - name: Create follow-up issue
        id: create-issue
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        env:
          ISSUE_TITLE: >-
            ${{ steps.generate.outputs.issue_title ||
            steps.fallback.outputs.issue_title }}
          ISSUE_BODY: >-
            ${{ steps.generate.outputs.issue_body ||
            steps.fallback.outputs.issue_body }}
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry } = retryHelpers;
            const title = process.env.ISSUE_TITLE;
            const body = process.env.ISSUE_BODY;

            if (!title || !body) {
              core.setFailed('Failed to generate issue title or body');
              return;
            }

            const issue = await withRetry(() => github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['follow-up']
            }));

            core.info(`Created issue #${issue.data.number}`);
            core.setOutput('issue_number', issue.data.number);
            core.setOutput('issue_url', issue.data.html_url);

      - name: Persist follow-up issue metadata
        if: steps.check-merged.outputs.merged == 'true'
        run: |
          cat <<'EOF' > followup_issue_output.json
          {
            "issue_number": "${{ steps.create-issue.outputs.issue_number }}",
            "issue_url": "${{ steps.create-issue.outputs.issue_url }}",
            "pr_number": "${{ steps.check-merged.outputs.pr_number }}",
            "workflow_run_id": "${{ github.run_id }}"
          }
          EOF

      - name: Upload follow-up issue metadata
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: verify-create-new-pr-output
          path: followup_issue_output.json
          if-no-files-found: error
          retention-days: 7

      - name: Comment on original PR
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        env:
          ISSUE_NUMBER: ${{ steps.create-issue.outputs.issue_number }}
          ISSUE_URL: ${{ steps.create-issue.outputs.issue_url }}
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry } = retryHelpers;
            const issueNumber = process.env.ISSUE_NUMBER;
            const issueUrl = process.env.ISSUE_URL;

            const body = [
              'ðŸ“‹ **Follow-up issue created:** #' + issueNumber,
              '',
              'Verification concerns have been analyzed and structured into a follow-up issue.',
              '',
              '**Next steps:**',
              '1. Review the generated issue',
              '2. Auto-pilot will continue preparing a new PR',
              '',
              '> Or work on it manually - the choice is yours!'
            ].join('\n');

            await withRetry(() => github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: body
            }));

      - name: Remove trigger label
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        continue-on-error: true
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry } = retryHelpers;
            try {
              await withRetry(() => github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                name: 'verify:create-new-pr'
              }));
              core.info('Removed verify:create-new-pr label');
            } catch (error) {
              core.warning('Could not remove label: ' + error.message);
            }
