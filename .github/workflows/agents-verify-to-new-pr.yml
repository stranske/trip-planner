name: Create New PR from Verification

# Creates a follow-up issue from verification feedback, then
# triggers auto-pilot to prepare a new PR.
#
# Trigger: Add `verify:create-new-pr` label to a merged PR

on:
  pull_request_target:
    types: [labeled]
permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: write
  models: read

env:
  PYTHON_VERSION: "3.12"

concurrency:
  group: >-
    agents-verify-to-new-pr-${{ github.repository }}-${{
      github.event.pull_request.number || github.run_id
    }}
  cancel-in-progress: false

jobs:
  create-new-pr:
    if: github.event.label.name == 'verify:create-new-pr'
    runs-on: ubuntu-latest
    steps:
      - name: Check PR is merged
        id: check-merged
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr.merged) {
              core.setFailed('PR must be merged before creating follow-up issue');
              return;
            }
            core.setOutput('merged', 'true');
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_title', pr.title);

      - name: Select GitHub token
        id: select-token
        if: steps.check-merged.outputs.merged == 'true'
        env:
          CODESPACES_WORKFLOWS: ${{ secrets.CODESPACES_WORKFLOWS }}
          OWNER_PR_PAT: ${{ secrets.OWNER_PR_PAT }}
          SERVICE_BOT_PAT: ${{ secrets.SERVICE_BOT_PAT }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          if [ -n "$CODESPACES_WORKFLOWS" ]; then
            echo "token=$CODESPACES_WORKFLOWS" >> "$GITHUB_OUTPUT"
            echo "source=codespaces" >> "$GITHUB_OUTPUT"
          elif [ -n "$OWNER_PR_PAT" ]; then
            echo "token=$OWNER_PR_PAT" >> "$GITHUB_OUTPUT"
            echo "source=owner-pat" >> "$GITHUB_OUTPUT"
          elif [ -n "$SERVICE_BOT_PAT" ]; then
            echo "token=$SERVICE_BOT_PAT" >> "$GITHUB_OUTPUT"
            echo "source=service-bot" >> "$GITHUB_OUTPUT"
          else
            echo "token=$GITHUB_TOKEN" >> "$GITHUB_OUTPUT"
            echo "source=github-token" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout repository
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/checkout@v6
        with:
          repository: stranske/Workflows
          token: ${{ steps.select-token.outputs.token }}
          sparse-checkout: |
            .github/actions/setup-api-client
            .github/scripts/github-api-with-retry.js
            .github/scripts/token_load_balancer.js
            scripts/langchain
            tools

      - name: Setup API client
        uses: ./.github/actions/setup-api-client
        with:
          secrets: ${{ toJSON(secrets) }}
          github_token: ${{ github.token }}



      - name: Set up Python
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        if: steps.check-merged.outputs.merged == 'true'
        run: |
          pip install langchain langchain-openai langchain-anthropic requests

      - name: Collect verification and original issue data
        id: collect
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry, paginateWithRetry } = retryHelpers;
            const prNumber = context.payload.pull_request.number;

            // Get all PR comments (handle pagination)
            const comments = await paginateWithRetry(
              github, github.rest.issues.listComments,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100
              }
            );

            // Find verification comment(s) - both evaluate and compare
            const verifyComments = comments.filter(c =>
              c.body.includes('## PR Verification Report') ||
              c.body.includes('## PR Verification Comparison') ||
              c.body.includes('### Concerns') ||
              c.body.includes('Verdict:') ||
              c.body.includes('### âš ï¸ Issues Detected')
            );

            if (verifyComments.length === 0) {
              core.setFailed(
                'No verification comment found. ' +
                'Add verify:evaluate or verify:compare label first.'
              );
              return;
            }

            // Combine all verification comments
            const verificationText = verifyComments.map(c => c.body).join('\n\n---\n\n');
            fs.writeFileSync('verification_data.txt', verificationText);
            core.info(`Found ${verifyComments.length} verification comment(s)`);

            // Extract linked issue from PR body
            const prBody = context.payload.pull_request.body || '';
            const issueMatches = prBody.match(
              /(close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*#(\d+)/gi
            );
            let linkedIssueNumber = null;

            if (issueMatches) {
              const match = issueMatches[0].match(/#(\d+)/);
              if (match) {
                linkedIssueNumber = parseInt(match[1]);
              }
            }

            // Also check PR preamble for "Source: Issue #NNN" pattern
            if (!linkedIssueNumber) {
              const sourceMatch = prBody.match(
                /\*\*Source:\*\*\s*Issue\s*#(\d+)/i
              );
              if (sourceMatch) {
                linkedIssueNumber = parseInt(sourceMatch[1]);
              }
            }

            // Also check PR title for issue reference
            if (!linkedIssueNumber) {
              const titleMatch = context.payload.pull_request.title.match(/#(\d+)/);
              if (titleMatch) {
                linkedIssueNumber = parseInt(titleMatch[1]);
              }
            }

            let originalIssueBody = '';
            let originalIssueTitle = '';

            if (linkedIssueNumber) {
              core.info(`Found linked issue #${linkedIssueNumber}`);
              try {
                const { data: issue } = await withRetry(
                  (client) => (client || github).rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: linkedIssueNumber
                }));
                originalIssueBody = issue.body || '';
                originalIssueTitle = issue.title || '';
                core.setOutput('original_issue_number', linkedIssueNumber);
                core.setOutput('original_issue_title', originalIssueTitle);
              } catch (error) {
                core.warning(`Could not fetch issue #${linkedIssueNumber}: ${error.message}`);
              }
            } else {
              core.warning('No linked issue found in PR body or title');
            }

            fs.writeFileSync('original_issue.txt', originalIssueBody);

            // --- Chain depth tracking (P0) ---
            // Extract follow-up-depth from original issue body or PR body
            // Format: <!-- follow-up-depth: N -->
            let chainDepth = 0;
            const depthSources = [originalIssueBody, prBody];
            for (const source of depthSources) {
              const depthMatch = source.match(
                /<!--\s*follow-up-depth:\s*(\d+)\s*-->/
              );
              if (depthMatch) {
                const parsed = parseInt(depthMatch[1], 10);
                if (parsed > chainDepth) chainDepth = parsed;
              }
            }
            // Also check if issue has 'follow-up' label (depth at least 1)
            if (chainDepth === 0 && linkedIssueNumber) {
              try {
                const { data: issueData } = await withRetry(
                  (client) => (client || github).rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: linkedIssueNumber
                  })
                );
                const hasFollowUpLabel = (issueData.labels || []).some(
                  l => (typeof l === 'string' ? l : l.name) === 'follow-up'
                );
                if (hasFollowUpLabel) chainDepth = Math.max(chainDepth, 1);
              } catch (_) { /* best effort */ }
            }
            core.info(`Follow-up chain depth: ${chainDepth}`);
            core.setOutput('chain_depth', String(chainDepth));

            // Set outputs
            core.setOutput('has_original_issue', linkedIssueNumber ? 'true' : 'false');

      - name: Check chain depth limit
        id: chain-check
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        env:
          CHAIN_DEPTH: ${{ steps.collect.outputs.chain_depth }}
          MAX_CHAIN_DEPTH: '2'
          LINKED_ISSUE: ${{ steps.collect.outputs.original_issue_number }}
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath =
              './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : { withRetry: (fn) => fn() };
            const { withRetry } = retryHelpers;

            const depth = parseInt(process.env.CHAIN_DEPTH || '0', 10);
            const maxDepth = parseInt(process.env.MAX_CHAIN_DEPTH || '2', 10);
            const prNumber = context.payload.pull_request.number;
            const linkedIssue = process.env.LINKED_ISSUE;

            if (depth >= maxDepth) {
              core.info(
                `Chain depth ${depth} >= max ${maxDepth}. ` +
                'Applying needs-human instead of creating follow-up.'
              );

              // Read verification data for the comment
              let verificationSummary = '';
              try {
                const raw = fs.readFileSync(
                  'verification_data.txt', 'utf8'
                );
                // Extract first 500 chars of concerns
                const concernsMatch = raw.match(
                  /### Concerns\s*\n([\s\S]*?)(?=###|##|$)/i
                );
                if (concernsMatch) {
                  verificationSummary = concernsMatch[1]
                    .trim().substring(0, 500);
                }
              } catch (_) { /* best effort */ }

              const comment = [
                'ðŸ›‘ **Follow-up chain depth limit reached** ' +
                  `(depth ${depth}/${maxDepth})`,
                '',
                'This PR has been through multiple verification â†’ ' +
                  'follow-up cycles. To prevent diminishing-returns ' +
                  'automation, `needs-human` has been applied instead ' +
                  'of creating another follow-up issue.',
                '',
                verificationSummary
                  ? '**Remaining verification concerns:**\n' +
                    verificationSummary
                  : '',
                '',
                '> A human should review whether the remaining ' +
                  'concerns warrant manual action or can be accepted.'
              ].filter(Boolean).join('\n');

              await withRetry(
                (client) => (client || github).rest.issues.createComment(
                  {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: comment
                  }
                )
              );

              // Apply needs-human to the PR
              await withRetry(
                (client) => (client || github).rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: ['needs-human']
                })
              );

              // Also apply to linked issue if available
              if (linkedIssue) {
                try {
                  await withRetry(
                    (client) =>
                      (client || github).rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: parseInt(linkedIssue, 10),
                        labels: ['needs-human']
                      })
                  );
                } catch (_) { /* best effort */ }
              }

              // Remove trigger label
              try {
                await withRetry(
                  (client) =>
                    (client || github).rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: prNumber,
                      name: 'verify:create-new-pr'
                    })
                );
              } catch (_) { /* best effort */ }

              core.setOutput('exceeded', 'true');
              return;
            }

            core.info(
              `Chain depth ${depth} < max ${maxDepth}. ` +
              'Proceeding with follow-up creation.'
            );
            core.setOutput('exceeded', 'false');
            core.setOutput('next_depth', String(depth + 1));

      - name: Extract verdict via verdict_policy
        id: extract-verdict
        if: >-
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true'
        continue-on-error: true
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          python -m scripts.langchain.verdict_extract \
            --summary-path verification_data.txt \
            --policy worst \
            --emit github

      - name: Apply needs-human from verdict policy
        id: verdict-needs-human
        if: >-
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true' &&
          steps.extract-verdict.outputs.needs_human == 'true'
        uses: actions/github-script@v8
        env:
          LINKED_ISSUE: ${{ steps.collect.outputs.original_issue_number }}
          NEEDS_HUMAN_REASON: ${{ steps.extract-verdict.outputs.needs_human_reason }}
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath =
              './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : { withRetry: (fn) => fn() };
            const { withRetry } = retryHelpers;

            const prNumber = context.payload.pull_request.number;
            const linkedIssue = process.env.LINKED_ISSUE;
            const reason = process.env.NEEDS_HUMAN_REASON || '';

            const comment = [
              'ðŸ›‘ **Verdict policy: needs-human**',
              '',
              'The deterministic verdict policy flagged this PR for ' +
                'human review due to a split verdict with low-confidence ' +
                'concerns.',
              '',
              reason ? `**Reason:** ${reason}` : '',
              '',
              '> A human should review whether the remaining ' +
                'concerns warrant manual action or can be accepted.'
            ].filter(Boolean).join('\n');

            await withRetry(
              (client) => (client || github).rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              })
            );

            await withRetry(
              (client) => (client || github).rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['needs-human']
              })
            );

            if (linkedIssue) {
              try {
                await withRetry(
                  (client) =>
                    (client || github).rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: parseInt(linkedIssue, 10),
                      labels: ['needs-human']
                    })
                );
              } catch (_) { /* best effort */ }
            }

      - name: Generate follow-up issue
        id: generate
        if: >-
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true' &&
          steps.extract-verdict.outputs.needs_human != 'true'
        continue-on-error: true
        env:
          PYTHONPATH: ${{ github.workspace }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CLAUDE_API_STRANSKE: ${{ secrets.CLAUDE_API_STRANSKE }}
          GITHUB_TOKEN: ${{ steps.select-token.outputs.token }}
          ORIGINAL_ISSUE_NUMBER: ${{ steps.collect.outputs.original_issue_number }}
          ORIGINAL_ISSUE_TITLE: ${{ steps.collect.outputs.original_issue_title }}
          PR_NUMBER: ${{ steps.check-merged.outputs.pr_number }}
          FOLLOW_UP_DEPTH: ${{ steps.chain-check.outputs.next_depth }}
        run: |
          # Generate using Python script
          python scripts/langchain/followup_issue_generator.py \
            --verification-comment verification_data.txt \
            --original-issue original_issue.txt \
            --original-issue-number "${ORIGINAL_ISSUE_NUMBER:-0}" \
            --original-issue-title "${ORIGINAL_ISSUE_TITLE:-}" \
            --pr-number "${PR_NUMBER}" \
            --json \
            --output followup_issue.json

          # Inject chain depth marker into generated body
          depth="${FOLLOW_UP_DEPTH:-1}"
          marker="<!-- follow-up-depth: ${depth} -->"
          jq --arg marker "$marker" \
            '.body = $marker + "\n" + .body' \
            followup_issue.json > followup_issue_tmp.json
          mv followup_issue_tmp.json followup_issue.json

          # Extract title and body for GitHub Actions
          echo "issue_title=$(jq -r '.title' followup_issue.json)" >> "$GITHUB_OUTPUT"

          # Use delimiter for multi-line body
          {
            echo 'issue_body<<EOF_ISSUE_BODY'
            jq -r '.body' followup_issue.json
            echo 'EOF_ISSUE_BODY'
          } >> "$GITHUB_OUTPUT"

      - name: Fallback to simple extraction
        id: fallback
        if: >-
          steps.generate.outcome == 'failure' &&
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true' &&
          steps.extract-verdict.outputs.needs_human != 'true'
        uses: actions/github-script@v8
        env:
          FOLLOW_UP_DEPTH: ${{ steps.chain-check.outputs.next_depth }}
          EXTRACTED_VERDICT: ${{ steps.extract-verdict.outputs.verdict }}
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            // Fallback to structured extraction if Python script fails
            const fs = require('fs');
            const prNumber = context.payload.pull_request.number;
            const prUrl = context.payload.pull_request.html_url;
            const depth = process.env.FOLLOW_UP_DEPTH || '1';

            let verificationText = '';
            try {
              verificationText = fs.readFileSync('verification_data.txt', 'utf8');
            } catch (error) {
              core.warning('Could not read verification data');
            }

            // --- Extract concerns from multiple formats ---
            const allConcerns = [];

            // Format 1: ### Concerns heading (verify:evaluate)
            const headingMatch = verificationText.match(
              /### Concerns\s*\n([\s\S]*?)(?=###|##|$)/i
            );
            if (headingMatch) {
              for (const line of headingMatch[1].split('\n')) {
                const t = line.trim().replace(/^[-*]\s*/, '');
                if (t && t.length > 15) allConcerns.push(t);
              }
            }

            // Format 2: - **Concerns:** bullet list (Provider Comparison Report)
            const bulletMatches = verificationText.matchAll(
              /- \*\*Concerns:\*\*\s*\n((?:\s+-\s+[^\n]+\n?)+)/g
            );
            for (const m of bulletMatches) {
              for (const line of m[1].split('\n')) {
                const t = line.trim().replace(/^-\s*/, '');
                if (t && t.length > 15) allConcerns.push(t);
              }
            }

            // Format 3: Unique Insights section
            const insightsMatch = verificationText.match(
              /### Unique Insights\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/
            );
            if (insightsMatch) {
              for (const line of insightsMatch[1].split('\n')) {
                if (!line.trim().startsWith('-')) continue;
                // Remove "- provider: " prefix
                const content = line.trim().replace(
                  /^-\s*\w+(?:-\w+)?:\s*/, ''
                );
                for (const c of content.split(';')) {
                  const t = c.trim();
                  if (t && t.length > 15) allConcerns.push(t);
                }
              }
            }

            // Deduplicate concerns
            const seen = new Set();
            const concerns = [];
            for (const c of allConcerns) {
              const key = c.toLowerCase();
              if (!seen.has(key)) {
                seen.add(key);
                concerns.push(c);
              }
            }

            // --- Extract verdict ---
            // Prefer the deterministic extraction from verdict_policy.py
            let verdict = process.env.EXTRACTED_VERDICT || '';

            // Fall back to regex extraction only when the Python
            // entrypoint did not produce a result.
            if (!verdict || verdict === 'Unknown') {
              const tableMatch = verificationText.match(
                /\|\s*\w+\s*\|[^|]+\|\s*(FAIL|CONCERNS|PASS)\s*\|/i
              );
              if (tableMatch) {
                verdict = tableMatch[1].toUpperCase();
              }
            }

            if (!verdict || verdict === 'Unknown') {
              const boldMatch = verificationText.match(
                /\*\*Verdict:\*\*\s*(\w+)/i
              );
              if (boldMatch) verdict = boldMatch[1];
            }

            // Format 3: Plain Verdict: WORD
            if (verdict === 'Unknown') {
              const plainMatch = verificationText.match(
                /Verdict:\s*(\w+)/i
              );
              if (plainMatch) verdict = plainMatch[1];
            }

            // --- Extract low scores ---
            const scoreMatches = [
              ...verificationText.matchAll(/(\w+):\s*(\d+(?:\.\d+)?)\/10/gi)
            ];
            const lowScores = scoreMatches
              .filter(m => parseFloat(m[2]) < 7)
              .map(m => `- ${m[1]}: ${m[2]}/10`);

            // --- Build issue body ---
            const hasConcerns = concerns.length > 0;
            const taskItems = hasConcerns
              ? concerns.slice(0, 12).map(c => {
                  const prefix = /^(add|fix|implement|update|ensure|create|write)/i
                    .test(c) ? '' : 'Address: ';
                  return `- [ ] ${prefix}${c}`;
                }).join('\n')
              : '- [ ] No specific concerns extracted.';

            const lowScoreSection = lowScores.length > 0
              ? '\n## Implementation Notes\n\nLow scores to address:\n' +
                [...new Set(lowScores)].join('\n')
              : '';

            const issueBody = [
              `<!-- follow-up-depth: ${depth} -->`,
              '## Why',
              '',
              `PR #${prNumber} was verified with verdict **${verdict}**. ` +
              'This follow-up issue tracks the remaining concerns.',
              '',
              '## Scope',
              '',
              `Address verification concerns from [PR #${prNumber}](${prUrl}).`,
              '',
              '## Tasks',
              '',
              taskItems,
              '',
              '## Acceptance Criteria',
              '',
              '- [ ] All verification concerns addressed or documented',
              '- [ ] Tests updated if needed',
              '- [ ] Re-verification passes',
              lowScoreSection,
              '',
              '---',
              '*Auto-generated by verify-to-new-pr workflow (fallback mode)*'
            ].join('\n');

            core.setOutput(
              'issue_title',
              `[Follow-up] Address verification concerns from PR #${prNumber}`
            );

            // Use environment file for multi-line output
            const envFile = process.env.GITHUB_OUTPUT;
            const delimiter = 'EOF_BODY';
            fs.appendFileSync(
              envFile,
              `issue_body<<${delimiter}\n${issueBody}\n${delimiter}\n`
            );

      - name: Create follow-up issue
        id: create-issue
        if: >-
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true' &&
          steps.extract-verdict.outputs.needs_human != 'true'
        uses: actions/github-script@v8
        env:
          ISSUE_TITLE: >-
            ${{ steps.generate.outputs.issue_title ||
            steps.fallback.outputs.issue_title }}
          ISSUE_BODY: >-
            ${{ steps.generate.outputs.issue_body ||
            steps.fallback.outputs.issue_body }}
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry, paginateWithRetry } = retryHelpers;

            const title = process.env.ISSUE_TITLE;
            const body = process.env.ISSUE_BODY;
            const prNumber = context.payload.pull_request.number;

            if (!title || !body) {
              core.setFailed('Failed to generate issue title or body');
              return;
            }

            // Deduplication: check if a follow-up issue already exists
            const existing = await paginateWithRetry(
              github, github.rest.issues.listForRepo,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'follow-up',
                per_page: 100
              }
            );
            const hasDuplicate = existing.some(issue =>
              issue.title.includes(`PR #${prNumber}`) &&
              issue.body && issue.body.includes(`PR #${prNumber}`)
            );
            if (hasDuplicate) {
              core.info(
                `Follow-up issue for PR #${prNumber} already exists, skipping`
              );
              // Set outputs so downstream steps don't fail
              const dup = existing.find(i =>
                i.title.includes(`PR #${prNumber}`)
              );
              core.setOutput('issue_number', dup.number);
              core.setOutput('issue_url', dup.html_url);
              return;
            }

            const issue = await withRetry((client) => (client || github).rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['follow-up', 'agent:codex', 'agents:auto-pilot']
            }));

            core.info(`Created issue #${issue.data.number}`);
            core.setOutput('issue_number', issue.data.number);
            core.setOutput('issue_url', issue.data.html_url);

      - name: Persist follow-up issue metadata
        if: >-
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true' &&
          steps.extract-verdict.outputs.needs_human != 'true'
        run: |
          cat <<'EOF' > followup_issue_output.json
          {
            "issue_number": "${{ steps.create-issue.outputs.issue_number }}",
            "issue_url": "${{ steps.create-issue.outputs.issue_url }}",
            "pr_number": "${{ steps.check-merged.outputs.pr_number }}",
            "workflow_run_id": "${{ github.run_id }}"
          }
          EOF

      - name: Upload follow-up issue metadata
        if: >-
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true' &&
          steps.extract-verdict.outputs.needs_human != 'true'
        uses: actions/upload-artifact@v6
        with:
          name: verify-create-new-pr-output
          path: followup_issue_output.json
          if-no-files-found: error
          retention-days: 7

      # Auto-pilot dispatch is handled by the bridge workflow
      # (agents-verify-to-new-pr-autopilot.yml) via workflow_run completion.
      # Do NOT add an inline dispatch here â€” it would create duplicate runs.

      - name: Comment on original PR
        if: >-
          steps.check-merged.outputs.merged == 'true' &&
          steps.chain-check.outputs.exceeded != 'true' &&
          steps.extract-verdict.outputs.needs_human != 'true'
        uses: actions/github-script@v8
        env:
          ISSUE_NUMBER: ${{ steps.create-issue.outputs.issue_number }}
          ISSUE_URL: ${{ steps.create-issue.outputs.issue_url }}
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry } = retryHelpers;

            const issueNumber = process.env.ISSUE_NUMBER;
            const issueUrl = process.env.ISSUE_URL;

            const body = [
              'ðŸ“‹ **Follow-up issue created:** #' + issueNumber,
              '',
              'Verification concerns have been analyzed and structured into a follow-up issue.',
              '',
              '**Next steps:**',
              '1. Review the generated issue',
              '2. Auto-pilot will continue preparing a new PR',
              '',
              '> Or work on it manually - the choice is yours!'
            ].join('\n');

            await withRetry((client) => (client || github).rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: body
            }));

      - name: Remove trigger label
        if: steps.check-merged.outputs.merged == 'true'
        uses: actions/github-script@v8
        continue-on-error: true
        with:
          github-token: ${{ steps.select-token.outputs.token }}
          script: |
            const fs = require('fs');
            const retryHelperPath = './.github/scripts/github-api-with-retry.js';
            const retryHelpers = fs.existsSync(retryHelperPath)
              ? require(retryHelperPath)
              : {
                  withRetry: (fn) => fn(),
                  paginateWithRetry: (githubInstance, method, params) =>
                    githubInstance.paginate(method, params),
                };
            const { withRetry } = retryHelpers;

            try {
              await withRetry((client) => (client || github).rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                name: 'verify:create-new-pr'
              }));
              core.info('Removed verify:create-new-pr label');
            } catch (error) {
              core.warning('Could not remove label: ' + error.message);
            }
