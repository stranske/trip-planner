# Thin caller for issue intake - delegates to Workflows repo reusable workflow
#
# Two modes:
# 1. Label-based (agent_bridge): Assigns agents to issues when labeled
#    with agent:* labels
# 2. ChatGPT sync (chatgpt_sync): Bulk creates issues from topic files
#    with optional LangChain formatting
#
# Triggers:
# - Issue opened/reopened/labeled with agent:* labels
# - Manual dispatch for both modes
#
# Copy this file to: .github/workflows/agents-issue-intake.yml
#
# Required secrets:
# - SERVICE_BOT_PAT: PAT for service bot account (comments, labels)
# - OWNER_PR_PAT: PAT for creating PRs on behalf of repository owner
name: Agents Issue Intake

on:
  issues:
    types:
      - opened
      - reopened
      - labeled
      - unlabeled
  workflow_dispatch:
    inputs:
      mode:
        description: "Mode: agent_bridge (label-based) or chatgpt_sync (bulk creation)"
        required: false
        type: choice
        options:
          - agent_bridge
          - chatgpt_sync
        default: agent_bridge
      issue_number:
        description: "[agent_bridge] Issue number to process"
        required: false
        type: string
      bridge_agent:
        description: "[agent_bridge] Agent to use (codex, copilot)"
        required: false
        type: string
        default: "codex"
      post_codex_comment:
        description: "[agent_bridge] Auto-post activation comment"
        required: false
        type: boolean
        default: true
      bridge_draft_pr:
        description: "[agent_bridge] Open bootstrap PRs as draft"
        required: false
        type: boolean
        default: false
      topic_files:
        description: "[chatgpt_sync] Topic files to sync (e.g., topics.json, agents/*.md)"
        required: false
        type: string
        default: ""
      apply_langchain_formatting:
        description: "[chatgpt_sync] Apply LangChain formatting to created issues"
        required: false
        type: boolean
        default: false

# NOTE: Top-level permissions block removed intentionally.
# When caller workflows have top-level permissions AND call reusable workflows,
# it can cause "startup_failure" with no jobs started.
# Jobs that need specific permissions declare them at job level.

jobs:
  # Determine which mode to run
  route:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.determine.outputs.mode }}
      should_run_bridge: ${{ steps.determine.outputs.should_run_bridge }}
      should_run_sync: ${{ steps.determine.outputs.should_run_sync }}
    steps:
      - name: Determine mode
        id: determine
        run: |
          echo "DEBUG: event_name=${{ github.event_name }}"
          echo "DEBUG: inputs.mode=${{ inputs.mode }}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            mode="${{ inputs.mode || 'agent_bridge' }}"
          else
            # Issue events always use agent_bridge mode
            mode="agent_bridge"
          fi
          echo "DEBUG: final mode=${mode}"
          echo "mode=${mode}" >> "$GITHUB_OUTPUT"

          if [[ "${mode}" == "agent_bridge" ]]; then
            echo "should_run_bridge=true" >> "$GITHUB_OUTPUT"
            echo "should_run_sync=false" >> "$GITHUB_OUTPUT"
          elif [[ "${mode}" == "chatgpt_sync" ]]; then
            echo "should_run_bridge=false" >> "$GITHUB_OUTPUT"
            echo "should_run_sync=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_run_bridge=false" >> "$GITHUB_OUTPUT"
            echo "should_run_sync=false" >> "$GITHUB_OUTPUT"
          fi

  # Gate for agent_bridge mode: only proceed if issue has agent:* or agents:* label
  # Skip when agents:auto-pilot is present - auto-pilot handles the full pipeline
  # Use exact array match (not substring) to avoid matching agents:auto-pilot-failed/pause
  check_labels:
    needs: route
    if: |
      needs.route.outputs.should_run_bridge == 'true' &&
      (github.event_name != 'issues' ||
       contains(toJson(github.event.issue.labels.*.name), 'agent:') ||
       contains(toJson(github.event.issue.labels.*.name), 'agents:')) &&
      !contains(github.event.issue.labels.*.name, 'agents:auto-pilot')
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      agent: ${{ steps.check.outputs.agent }}
    steps:
      - name: Check labels and extract info
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            const eventName = context.eventName;
            let issueNumber = '${{ inputs.issue_number }}' || '';
            let agent = '${{ inputs.bridge_agent }}' || 'codex';

            // Metadata labels that aren't actual agent assignments
            const metadataLabels = new Set([
              'keepalive', 'formatted', 'optimize', 'allow-change',
              'apply-suggestions', 'debug', 'format', 'sync-failed', 'sync-required'
            ]);

            if (eventName === 'issues') {
              const issue = context.payload.issue;
              issueNumber = String(issue.number);

              // Extract agent from labels (agent:codex, agents:codex, etc.)
              // Skip metadata labels that aren't actual agent assignments
              const labels = issue.labels.map(l => l.name);
              const agentLabel = labels.find(l => {
                const match = l.match(/^agents?:([a-z-]+)$/i);
                if (!match) return false;
                const suffix = match[1].toLowerCase();
                return !metadataLabels.has(suffix);
              });
              if (agentLabel) {
                agent = agentLabel.replace(/^agents?:/, '').toLowerCase();
              }

              // Check if any actual agent assignment label exists (not metadata)
              const hasAgentLabel = labels.some(l => {
                const match = l.match(/^agents?:([a-z-]+)$/i);
                if (!match) return false;
                const suffix = match[1].toLowerCase();
                return !metadataLabels.has(suffix);
              });
              if (!hasAgentLabel) {
                core.setOutput('should_run', 'false');
                return;
              }
            }

            core.setOutput('should_run', 'true');
            core.setOutput('issue_number', issueNumber);
            core.setOutput('agent', agent);
            console.log(`Processing issue #${issueNumber} with agent: ${agent}`);

  # Agent bridge mode: Call the Workflows repo reusable issue bridge
  bridge:
    needs: [route, check_labels]
    if: |
      needs.route.outputs.should_run_bridge == 'true' &&
      needs.check_labels.outputs.should_run == 'true'
    uses: stranske/Workflows/.github/workflows/reusable-agents-issue-bridge.yml@main
    with:
      agent: ${{ needs.check_labels.outputs.agent }}
      issue_number: ${{ needs.check_labels.outputs.issue_number }}
      mode: "create"
      force_mode: true
      # Skip post_agent_comment for codex - CLI keepalive loop handles it,
      # posting @codex would trigger UI agent alongside CLI causing conflicts
      post_agent_comment: >-
        ${{ github.event_name == 'workflow_dispatch'
            && (inputs.post_codex_comment && 'true' || 'false')
            || (needs.check_labels.outputs.agent != 'codex' && 'true' || 'false') }}
      agent_pr_draft: ${{ inputs.bridge_draft_pr && 'true' || 'false' }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      owner_pr_pat: ${{ secrets.OWNER_PR_PAT }}
      workflows_app_id: ${{ secrets.WORKFLOWS_APP_ID }}
      workflows_app_private_key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

  # ChatGPT sync mode: Call the Workflows repo reusable workflow with sync capability
  sync:
    needs: route
    if: needs.route.outputs.should_run_sync == 'true'
    permissions:
      contents: write
      issues: write
      id-token: write
      models: read
      pull-requests: write
    uses: stranske/Workflows/.github/workflows/agents-63-issue-intake.yml@main
    with:
      intake_mode: "chatgpt_sync"
      source: ${{ inputs.topic_files }}
      apply_langchain_formatting: ${{ inputs.apply_langchain_formatting && 'true' || 'false' }}
    secrets: inherit
