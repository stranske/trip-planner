# Thin caller for issue intake - delegates to Workflows repo reusable workflow
#
# Two modes:
# 1. Label-based (agent_bridge): Assigns agents to issues when labeled
#    with agent:* labels
# 2. ChatGPT sync (chatgpt_sync): Bulk creates issues from topic files
#    with optional LangChain formatting
#
# Triggers:
# - Issue opened/reopened/labeled with agent:* labels
# - Manual dispatch for both modes
#
# Copy this file to: .github/workflows/agents-issue-intake.yml
#
# Required secrets:
# - SERVICE_BOT_PAT: PAT for service bot account (comments, labels)
# - OWNER_PR_PAT: PAT for creating PRs on behalf of repository owner
name: Agents Issue Intake

on:
  issues:
    types:
      - opened
      - reopened
      - labeled
      - unlabeled
  workflow_dispatch:
    inputs:
      mode:
        description: "Mode: agent_bridge (label-based) or chatgpt_sync (bulk creation)"
        required: false
        type: choice
        options:
          - agent_bridge
          - chatgpt_sync
        default: agent_bridge
      issue_number:
        description: "[agent_bridge] Issue number to process"
        required: false
        type: string
      bridge_agent:
        description: "[agent_bridge] Agent to use (codex, copilot)"
        required: false
        type: string
        default: "codex"
      post_codex_comment:
        description: "[agent_bridge] Auto-post activation comment"
        required: false
        type: boolean
        default: true
      bridge_draft_pr:
        description: "[agent_bridge] Open bootstrap PRs as draft"
        required: false
        type: boolean
        default: false
      topic_files:
        description: "[chatgpt_sync] Topic files to sync (e.g., topics.json, agents/*.md)"
        required: false
        type: string
        default: ""
      apply_langchain_formatting:
        description: "[chatgpt_sync] Apply LangChain formatting to created issues"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: issue-intake-${{ github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  # Determine which mode to run
  route:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.determine.outputs.mode }}
      should_run_bridge: ${{ steps.determine.outputs.should_run_bridge }}
      should_run_sync: ${{ steps.determine.outputs.should_run_sync }}
    steps:
      - name: Determine mode
        id: determine
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            mode="${{ inputs.mode || 'agent_bridge' }}"
          else
            # Issue events always use agent_bridge mode
            mode="agent_bridge"
          fi

          echo "mode=${mode}" >> $GITHUB_OUTPUT

          if [[ "${mode}" == "agent_bridge" ]]; then
            echo "should_run_bridge=true" >> $GITHUB_OUTPUT
            echo "should_run_sync=false" >> $GITHUB_OUTPUT
          elif [[ "${mode}" == "chatgpt_sync" ]]; then
            echo "should_run_bridge=false" >> $GITHUB_OUTPUT
            echo "should_run_sync=true" >> $GITHUB_OUTPUT
          else
            echo "should_run_bridge=false" >> $GITHUB_OUTPUT
            echo "should_run_sync=false" >> $GITHUB_OUTPUT
          fi

  # Gate for agent_bridge mode: only proceed if issue has agent:* or agents:* label
  check_labels:
    needs: route
    if: |
      needs.route.outputs.should_run_bridge == 'true' &&
      (github.event_name != 'issues' ||
       contains(toJson(github.event.issue.labels.*.name), 'agent:') ||
       contains(toJson(github.event.issue.labels.*.name), 'agents:'))
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      agent: ${{ steps.check.outputs.agent }}
    steps:
      - name: Check labels and extract info
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            const eventName = context.eventName;
            let issueNumber = '${{ inputs.issue_number }}' || '';
            let agent = '${{ inputs.bridge_agent }}' || 'codex';

            if (eventName === 'issues') {
              const issue = context.payload.issue;
              issueNumber = String(issue.number);

              // Extract agent from labels (agent:codex, agents:codex, etc.)
              const labels = issue.labels.map(l => l.name);
              const agentLabel = labels.find(
                l => /^agents?:[a-z]+$/i.test(l) && !l.includes('keepalive')
              );
              if (agentLabel) {
                agent = agentLabel.replace(/^agents?:/, '').toLowerCase();
              }

              // Check if any agent label exists
              const hasAgentLabel = labels.some(l => /^agents?:/.test(l));
              if (!hasAgentLabel) {
                core.setOutput('should_run', 'false');
                return;
              }
            }

            core.setOutput('should_run', 'true');
            core.setOutput('issue_number', issueNumber);
            core.setOutput('agent', agent);
            console.log(`Processing issue #${issueNumber} with agent: ${agent}`);

  # Agent bridge mode: Call the Workflows repo reusable issue bridge
  bridge:
    needs: [route, check_labels]
    if: |
      needs.route.outputs.should_run_bridge == 'true' &&
      needs.check_labels.outputs.should_run == 'true'
    uses: stranske/Workflows/.github/workflows/reusable-agents-issue-bridge.yml@main
    with:
      agent: ${{ needs.check_labels.outputs.agent }}
      issue_number: ${{ needs.check_labels.outputs.issue_number }}
      mode: "create"
      post_agent_comment: ${{ inputs.post_codex_comment && 'true' || 'false' }}
      agent_pr_draft: ${{ inputs.bridge_draft_pr && 'true' || 'false' }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      owner_pr_pat: ${{ secrets.OWNER_PR_PAT }}

  # ChatGPT sync mode: Call the Workflows repo reusable workflow with sync capability
  sync:
    needs: route
    if: needs.route.outputs.should_run_sync == 'true'
    permissions:
      contents: read
      issues: write
      id-token: write
      models: read
    uses: stranske/Workflows/.github/workflows/agents-63-issue-intake.yml@main
    with:
      intake_mode: "chatgpt_sync"
      source: ${{ inputs.topic_files }}
      apply_langchain_formatting: ${{ inputs.apply_langchain_formatting && 'true' || 'false' }}
    secrets: inherit
